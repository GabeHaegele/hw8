#include <iostream>
#include <cstdlib>
#include <iomanip>
#include <cmath>

using namespace std;

const int MAX = 17;

class fish
{
  private:
    int m_food;
    int m_x;
    int m_y;
    bool m_alive;
  public:
    fish();
    void move();
    void setXY(const int x, const int y);
    int getX() const;
    int getY() const;
    int getFood() const;
    void setAlive(const bool status);
};

class penguin
{
  private:
    int m_health;
    int m_x;
    int m_y;
    bool m_alive;
  public:
    penguin();
    void move();
    void setXY(const int x, const int y);
    int getX() const;
    int getY() const;
};

class killer_whale
{
  private:
    int m_x;
    int m_y;
    int m_kills;
  public:
    killer_whale();
    void move();
    void setXY(const int x, const int y);
    int getX() const;
    int getY() const;
};

class sea
{
  private:
    char m_waters[MAX][MAX];
    short m_sea_size;
    void clear();
    void populate(penguin pArr[], const int pSize, fish fArr[], const int fSize, killer_whale wArr[], const int wSize);
  public:
    sea(penguin pArr[], const int pSize, fish fArr[], const int fSize, killer_whale wArr[], const int wSize, const short grid_size=MAX);
    //overloaded insertion operator
    //Getter/Setters
    friend ostream & operator << (ostream &out, const sea &sea);
};

int main()
{
  srand(10);

  cout << "Hello world!" << endl;

  fish fishies[200];

  penguin pengies[50];

  killer_whale whalies[2];

  sea testWaters(pengies, 20, fishies, 35, whalies, 2, 17);

  cout<<testWaters;

  return 0;
}

void sea::clear()
{
  for(int i=0; i<m_sea_size; i++)
  {
    for(int j=0; j<m_sea_size; j++)
    {
      m_waters[i][j]='~';
    }
  }
  return;
}

void sea::populate(penguin pArr[], const int pSize, fish fArr[], const int fSize, killer_whale wArr[], const int wSize)
{
  int fPlaced=0;
  int pPlaced=0;
  int wPlaced=0;
  bool placed=false;
  int loops = 0;
  while(fPlaced<fSize || pPlaced<pSize || wPlaced<wSize)
  {
    loops++;
    for(int i=0; i<m_sea_size; i++)
    {
      for(int j=0; j<m_sea_size; j++)
      {
        if(m_waters[i][j]=='~')
        {
          placed=false;
          if(fPlaced<fSize)
          {
            if((rand()%100)<10)
            {
              m_waters[i][j]='F';
              fArr[fPlaced].setXY(i,j);
              fPlaced++;
              placed=true;
            }
          }
          if(pPlaced<pSize && !placed)
          {
            if((rand()%100)<10)
            {
              m_waters[i][j]='P';
              pArr[pPlaced].setXY(i,j);
              pPlaced++;
              placed=true;
            }
          }
          if(wPlaced<wSize && !placed)
          {
            if((rand()%100)<2)
            {
              m_waters[i][j]='K';
              wArr[wPlaced].setXY(i,j);
              wPlaced++;
            }
          }
        }
      }
    }
  }
  cout<<"\nLoops: "<<loops<<endl;
  return;
}

sea::sea(penguin pArr[], const int pSize, fish fArr[], const int fSize, killer_whale wArr[], const int wSize, const short grid_size)
{
  m_sea_size=grid_size;
  clear();
  populate(pArr, pSize, fArr, fSize, wArr, wSize);
}

ostream & operator << (ostream &out, const sea &sea)
{
  out<<left<<"   ";
  for(int i=0; i<sea.m_sea_size; i++)
  {
    out<<setw(2)<<i<<" ";//Top row of numbers
  }
  out<<endl;

  for(int i=0; i<sea.m_sea_size; i++)
  {
    out<<setw(2)<<i<<" ";//Left column of numbers
    for(int j=0; j<sea.m_sea_size; j++)
    {
      out<<sea.m_waters[i][j]<<"  ";
    }
    out<<endl;
  }
  return out;
}

//fish

fish::fish()
{
  m_food=(rand()%10)+1;
  m_x=-1;
  m_y=-1;
  m_alive=false;
}

int fish::getFood() const
{
  return m_food;
}

void fish::setAlive(const bool status)
{
  m_alive=status;
}

void fish::setXY(const int x, const int y)
{
  m_x=x;
  m_y=y;
}

int fish::getX() const
{
  return m_x;
}

int fish::getY() const
{
  return m_y;
}

//penguin

penguin::penguin()
{
  m_health=(rand()%21)+60;
  m_x=-1;
  m_y=-1;
  m_alive=false;
}

void penguin::move(sea &sea, fish fArr[], const int fSize)
{
  int minX_vision=0;
  int maxX_vision=0;
  int minY_vision=0;
  int maxY_vision=0;
  int optimalFishX=-1;
  int optimalFishY=-1;
  int scariestWhaleX=-1;
  int scariestWhaleY=-1;
  int randomMove=0;
  if(!(m_x==-1 || m_y==-1))
  {
    bool ate = false;
    int moves=0;
    if(m_health>80)
    {
      moves=5;
    } else if(m_health>60)
    {
      moves=4;
    } else if(m_health>40)
    {
      moves=3;
    } else if(m_health>20)
    {
      moves=2;
    } else if(m_health>0)
    {
      moves=1;
    }
    while(moves>0 && ate=false)
    {
      if(m_x>8)
      {
        minX_vision=m_x-8;
        if(m_x<(sea.m_sea_size-8))
        {
          maxX_vision=m_x+8;
        } else
        {
          maxX_vision=sea.m_sea_size;
        }
      }
      if(m_y>8)
      {
        minY_vision=m_y-8;
        if(m_y<(sea.m_sea_size-8))
        {
          maxY_vision=m_y+8;
        } else
        {
          maxY_vision=sea.m_sea_size;
        }
      }
      optimalFishX=-1;
      optimalFishY=-1;
      scariestWhaleX=-1;
      scariestWhaleY=-1;
      for(int i=minX_vision; i<maxX_vision; i++)//Scouting report
      {
        for(int j=minY_vision; j<maxY_vision; j++)
        {
          if(sea.m_waters[i][j]=='F')
          {
            if(sqrt(((m_x-i)*(m_x-i))+((m_y-j)*(m_y-j)))<sqrt(((m_x-optimalFishX)*(m_x-optimalFishX))+((m_y-optimalFishY)*(m_y-optimalFishY)))
            {
              optimalFishX=i;
              optimalFishY=j;
            }
          }
          if(sea.m_waters[i][j]=='K')
          {
            if(sqrt(((m_x-i)*(m_x-i))+((m_y-j)*(m_y-j)))<sqrt(((m_x-scariestWhaleX)*(m_x-scariestWhaleX))+((m_y-scariestWhaleY)*(m_y-scariestWhaleY)))
            {
              scariestWhaleX=i;
              scariestWhaleY=j;
            }
          }
        }
      }

      if(optimalFishX==-1 && scariestWhaleX==-1)
      {
        randomMove=rand()%8+1;
        switch(randomMove)
        {
          case 1:
            m_x+=1;
            break;
          case 2:
            m_x+=1;
            m_y+=1;
            break;
          case 3:
            m_y+=1;
            break;
          case 4:
            m_y+=1;
            m_x-=1;
            break;
          case 5:
            m_x-=1;
            break;
          case 6:
            m_x-=1;
            m_y-=1;
            break;
          case 7:
            m_y-=1;
            break;
          case 8:
            m_x+=1;
            m_y-=1;
            break;
        }
      } else
      {
        //When the penguin moves, i must implement a check that it does not move on
        //top of a penguin.dw about fish or whale tho
        if(scariestWhaleX!=-1)
        {
          if(scariestWhaleX>m_x)
          {
            m_x-=1;
          } else if(scariestWhaleX!=m_x)
          {
            m_x+=1;
          }

          if(scariestWhaleY>m_y)
          {
            m_y-=1;
          } else if(scariestWhaleY!=m_y)
          {
            m_y+=1;
          }
        } else if(optimalFishX!=-1)
        {
          if(optimalFishX>m_x)
          {
            m_x+=1;
          } else if(optimalFishX!=m_x)
          {
            m_x-=1;
          }

          if(optimalFishY>m_y)
          {
            m_y+=1;
          } else if(optimalFishY!=m_y)
          {
            m_y-=1;
          }
        }
      }
      moves--;
      for(int i=0; i<fSize; i++)
      {
        if(fArr[i].getX()==m_x && fArr[i].getY()==m_y)
        {
          ate=true;
          fArr[i].setAlive(false);
          m_health+=fArr[i].getFood();
        }
      }
    }

  }
}

void penguin::setXY(const int x, const int y)
{
  m_x=x;
  m_y=y;
}

int penguin::getX() const
{
  return m_x;
}

int penguin::getY() const
{
  return m_y;
}

//whale

killer_whale::killer_whale()
{
  m_x=-1;
  m_y=-1;
  m_kills=0;
}

void killer_whale::setXY(const int x, const int y)
{
  m_x=x;
  m_y=y;
}

int killer_whale::getX() const
{
  return m_x;
}

int killer_whale::getY() const
{
  return m_y;
}
